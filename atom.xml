<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Zoom-EobardThawne.github.io</id>
    <title>闲卧庭前远看帆</title>
    <updated>2021-11-03T04:55:10.258Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Zoom-EobardThawne.github.io"/>
    <link rel="self" href="https://Zoom-EobardThawne.github.io/atom.xml"/>
    <subtitle>欲买桂花同载酒，终不似，少年游</subtitle>
    <logo>https://Zoom-EobardThawne.github.io/images/avatar.png</logo>
    <icon>https://Zoom-EobardThawne.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 闲卧庭前远看帆</rights>
    <entry>
        <title type="html"><![CDATA[【每日科技】——app推荐]]></title>
        <id>https://Zoom-EobardThawne.github.io/post/iDaily-app/</id>
        <link href="https://Zoom-EobardThawne.github.io/post/iDaily-app/">
        </link>
        <updated>2021-11-03T03:01:37.000Z</updated>
        <content type="html"><![CDATA[<p><em>「每日科技」（四叶新媒体）2011 年 12 月成立，旗下App众多，包括 iDaily·每日环球视野、倒数日、imoney、iMuseum·每日环球展览等。覆盖金融、媒体、艺术、效率、工具、天气、社交等多领域。</em></p>
<p>今天主要推荐的是个人使用过的三款app：<strong>DaysMaster、iHour、iBetter</strong>。<br>
这三款App，均在Android和iOS的应用商店上架。使用时，通过注册登录“<a href="https://icity.ly/">iCity</a>”账号，就可以跨设备数据同步，实时更新自己的使用记录。</p>
<h2 id="daysmaster不再忘记重要的日子"><strong>DaysMaster——不再忘记重要的日子</strong></h2>
<p><u><em>「倒数日 · Days Matter」是一个帮你记录生活中重要日子的小工具，例如:发工资还有多少天？还信用卡还有多少天？恋人生日还有多少天？宝宝出生已经多少天？来到地球已经多少天……</em></u><br>
<img src="https://Zoom-EobardThawne.github.io/post-images/1635909083162.png" alt="" loading="lazy"><br>
=主要功能=<br>
1、万年支持：支持从公元元年 1 月 1 日到公元 9999 年 12 月 31 日的倒数/正数日期，你可以计算诸如美国独立多少日、与女朋友交往多少日、宝宝出生多少日……<br>
2、农历支持：支持从 1901 年至 2049 年的农历日期<br>
3、支持添加桌面挂件<br>
4、三种默认分类：纪念日、工作、生活，支持自定义更多分类<br>
5、重要日期醒目置顶支持，支持时间远近排序<br>
6、 历史上的今天<br>
7、日期计算器<br>
8、自定义事件背景<br>
9、高级功能：密码保护</p>
<h2 id="ihour时间投资计划"><strong>iHour——时间投资计划</strong></h2>
<p><u><em>「iHour·时间投资计划」是一个帮助你规划、记录自己时间投入的 app，可以帮助你记录「背单词多少小时」「练琴多少小时」「看书多少小时」「Coding 多少小时」等需要时间累积来提高的技能。特有每日定时提醒，事件正倒数计时器，支持长达 10 年的时间规划。特别设计的成就系统，帮助你突飞猛进。对任何一件事情投入 1 万小时，你都可以成为这个领域的专家。</em></u><br>
<img src="https://Zoom-EobardThawne.github.io/post-images/1635911550469.png" alt="" loading="lazy"><br>
=特别亮点=<br>
1.每日记录：记录每天不同项目投入小时数。支持提醒和计时。<br>
2.项目进度：呈现每个项目累计投入时间。<br>
3.图表统计：最直观的投入时间统计分析。<br>
4.成就挑战：80 余个成就等待挑战，隐藏成就让 app 探索充满惊喜。<br>
5.分享是美德：通过微博、微信分享你的成就，互相鼓励。</p>
<h2 id="ibetter人生养成计划"><strong>iBetter——人生养成计划</strong></h2>
<p><u><em>「iBetter·人生养成计划」，这是一个帮助你「养成好习惯」、「戒掉坏习惯」的 App，每天提醒和鼓励你，记录你的进步，还有超酷的勋章可以收集。我们的目标是：7天养成一个好习惯。</em></u><br>
<img src="https://Zoom-EobardThawne.github.io/post-images/1635911618715.png" alt="" loading="lazy"><br>
特别亮点：<br>
1.每日提醒：早上和晚上提醒你要坚持的习惯，绝不忘记<br>
2.成就记录：让你看到每一天自己的成就，更加鼓舞<br>
3.超酷勋章：超过100个超酷勋章等待你去赢得<br>
4.分享：将你的纪录分享给朋友们<br>
5.全平台：移动设备跨平台同步</p>
<h2 id="summary">Summary:</h2>
<p>再好的产品也需要用户认真使用，才能发挥应有的作用。工具知识辅助，重要的是帮助我们更好的生活，希望我们保持热爱的心，积极的面对生活的挑战，达成自己的目标。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Gridea使用Tips】无法保存主题自定义设置]]></title>
        <id>https://Zoom-EobardThawne.github.io/post/grideaTips-1/</id>
        <link href="https://Zoom-EobardThawne.github.io/post/grideaTips-1/">
        </link>
        <updated>2021-11-02T13:23:34.000Z</updated>
        <content type="html"><![CDATA[<p><em><u><a href="https://gridea.dev/"><strong>Gridea</strong></a>——一个静态博客写作的客户端。<br>
在Gridea上进行写作，配合Github Pages或Coding Pages平台服务，就可以将自己的博客部署到网络上。<br>
本站也是通过这种方式搭建的，成本低、自由度高、可选的主题丰富，部署稍微麻烦些，不如注册现成的博客网站来的快捷。但对于想要尝试搭建个人博客，缺乏编程经验的人来说是一个很好的选择。</u></em></p>
<p>在使用过程中难免遇到一些问题，比如本文将提到的<strong>客户端无法保存主题自定义设置</strong>。</p>
<p>今天想要给自己的博客添加评论功能，刚好选择的主题“<a href="https://github.com/lmm214/gridea-theme-breek/"><strong>Breek</strong></a>”中自带<a href="https://valine.js.org/"><strong>valine</strong></a>评论系统，只需要在设置中填入相关信息就可以添加valine评论到博客。填好相关信息之后，我发现点击保存按钮并无反应，重启客户端保存的设置消失了，尝试了多次之后并未找出原因。<br>
<img src="https://Zoom-EobardThawne.github.io/post-images/1635861185701.png" alt="" loading="lazy"><br>
最后只得手动修改客户端的配置文件，填入相关信息了。<br>
具体步骤如下图：<br>
<img src="https://Zoom-EobardThawne.github.io/post-images/1635861378518.png" alt="" loading="lazy"><br>
<img src="https://Zoom-EobardThawne.github.io/post-images/1635861387948.png" alt="" loading="lazy"><br>
通过这种方式，成功将信息添加到了客户端配置中，但是无法保存配置的原因仍然不明。可能是软件本身bug？或者是我使用的主题和设置有冲突？<br>
天色太晚了，先到这里吧。</p>
<hr>
<p>往期推荐：<br>
<a href="https://xn--yetp9bp76b6xdqv7b.top/post/Miru-Tights%20/">みるタイツ/Miru Tights </a><br>
<a href="https://xn--yetp9bp76b6xdqv7b.top/post/dc-guan-ying/">DC观影</a></p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《みるタイツ/Miru Tights 》——朦胧的色气]]></title>
        <id>https://Zoom-EobardThawne.github.io/post/Miru-Tights /</id>
        <link href="https://Zoom-EobardThawne.github.io/post/Miru-Tights /">
        </link>
        <updated>2021-11-01T11:10:28.000Z</updated>
        <content type="html"><![CDATA[<p><em>《裤袜视界》（みるタイツ / Miru Tights ）主要讲述了春天成为高二生的蓝川莲、文体兼优的中红由亚、开朗活泼的大小姐萌黄帆美三人的度过的一段“无可替代的时光”。</em></p>
<p><u><strong>4月，下雨的早晨。开始凋零的樱花被雨滴打落，漂浮在积水之上。学生们撑着五颜六色的雨伞，穿过高中的校门。<br>
“早啊，莲”。鞋柜前，裤袜湿透的莲被由亚搭话。略显忧郁的莲回过头去，看到全身湿透的帆美蹦蹦跳跳地走来，热闹地说着话。3个女学生没啥营养的对话，向教室宣告了新学期的来临。<br>
少女们无可替代的宝贵时间向前飞逝，季节渐渐转变……</strong></u></p>
<p>资料参考：<a href="https://zh.moegirl.org.cn/%E8%A3%A4%E8%A2%9C%E8%A7%86%E7%95%8C"><strong>萌娘百科</strong></a></p>
<p><em><strong>三位主角</strong></em></p>
<p><strong>蓝川莲</strong>（CV：户松遥）<br>
自春天起就升上高二的普通女孩子。<br>
表面上高冷但其实很容易害羞，有着“无法拒绝拜托”的性格。<br>
放学后在附近的咖啡店打工。<br>
身高162cm。<br>
喜欢60丹尼尔的裤袜。<br>
<img src="https://Zoom-EobardThawne.github.io/post-images/1635770076910.jpg" alt="" loading="lazy"><br>
<strong>中红由亚</strong>（CV：日笠阳子）<br>
又译作“悠亚”。<br>
文武双全的优等生，话少但是沟通能力强，时不时会调侃莲。<br>
兴趣是在社交平台上发Cosplay自拍推特福利姬，人气很高。Twitter名字是“つぶ餡”。<br>
身高168cm。<br>
喜欢30丹尼尔的裤袜。<br>
<img src="https://Zoom-EobardThawne.github.io/post-images/1635770093498.jpg" alt="" loading="lazy"><br>
<strong>萌黄帆美</strong>（CV：洲崎绫）<br>
又译作“穗美”。<br>
开朗活泼的大小姐。有着天然（呆）的性格，常常让周围的人感到无语。<br>
配有专属司机上下学，是游泳部成员。另外还有个读初中的弟弟，有次调戏了弟弟，说了些奇怪的话。（实则是在掏耳朵）<br>
身高158cm。<br>
喜欢110丹尼尔的裤袜。<br>
<img src="https://Zoom-EobardThawne.github.io/post-images/1635770106082.jpg" alt="" loading="lazy"></p>
<p><em>动画的配乐十分舒缓，JK的生活片段拼凑起的平淡日常，营造了一种惬意慵懒却又洋溢青春气息的氛围。在剧情方面，本作就乏善可陈了（甚至你大可以认为，本作压根不存在剧情一说，就是一个个零散的日常描写，一幅幅场景的堆叠），对于剧情有高要求的观众，或许会觉得本作十分无聊。</em></p>
<figure data-type="image" tabindex="1"><img src="https://Zoom-EobardThawne.github.io/post-images/1635770225903.jpg" alt="" loading="lazy"></figure>
<p><em>诚然，剧情什么也不会是本作受众关注的重点，本作的核心卖点是各种裤袜的展示。在画师笔下款式各异、薄厚不一的裤袜，在修饰身体曲线的同时，更增加了朦胧的神秘感，勾起人心底深处的好奇。</em></p>
<figure data-type="image" tabindex="2"><img src="https://Zoom-EobardThawne.github.io/post-images/1635770238639.png" alt="" loading="lazy"></figure>
<p><em>本作的人物互动充满暧昧和挑逗的意味，却总是在紧要处戛然而止，将画面之外的细节留给观众去想象。（<s>动画第七集，在放学后的教室里，女老师和男同学究竟发生了什么？？？究竟是梦还是真实？？？动画虽未明确交代，但老师穿裤袜的动作、同学敞开的衣衫、老师离开时的奇怪步态都在暗示着事情并不简单</s>）</em></p>
<figure data-type="image" tabindex="3"><img src="https://Zoom-EobardThawne.github.io/post-images/1635850083505.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://Zoom-EobardThawne.github.io/post-images/1635770558654.png" alt="" loading="lazy"></figure>
<p>汉化资源：<a href="https://acg.rip/t/208643.torrent"><strong>悠哈璃羽字幕社</strong></a></p>
<p><em><strong>21年11月2日更新内容</strong></em></p>
<p>原作画师——<a href="https://zh.moegirl.org.cn/Yom"><strong>よむ</strong></a>，日本的插画家。<br>
2015年10月在成人向杂志《COMIC高》上出道，作品主题大多为裤袜。担任原作的Web动画《裤袜视界》于2019年5月播出。2019年9月开始在推特上不定期连载漫画《加油啊同期酱》，后以社团よむ書店的名义出版同人本。</p>
<p>附上作者的网络账号地址：（记住科学上网）<br>
<a href="https://yomtights.com/">よむ的个人网站</a><br>
<a href="https://twitter.com/y_o_m_y_o_m">よむ的推特主页</a><br>
<a href="https://www.pixiv.net/users/6210796">よむ的Pixiv主页</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DC观影]]></title>
        <id>https://Zoom-EobardThawne.github.io/post/dc-guan-ying/</id>
        <link href="https://Zoom-EobardThawne.github.io/post/dc-guan-ying/">
        </link>
        <updated>2021-11-01T09:07:04.000Z</updated>
        <content type="html"><![CDATA[<p><em>安利向！本文中提及的作品本人均完整观看过，根据个人喜好整理，排名不分先后。</em></p>
<h1 id="dc动画tv">DC动画TV</h1>
<h2 id="1-justice-league-unlimited正义联盟无限超人正义联盟">1、Justice League Unlimited(正义联盟无限/超人正义联盟)</h2>
<p>动画共五季</p>
<p>本作讲述了超人、蝙蝠侠等英雄组建正义联盟，共同应对各种危机的故事。剧中登场了众多超级英雄，既有细腻的个人刻画，也有激动人心的团队作战。本作观影门槛不高，即使此前完全不了解DC系列的作品，也能轻松在本作中收获乐趣。这个版本的超人还是童年记忆中的经典豆豆眼形象，蝙蝠侠和神奇女侠在这个系列的故事中发展了感情线，剧中还有许多发糖的桥段（作为BW党十分满足）。</p>
<figure data-type="image" tabindex="1"><img src="https://Zoom-EobardThawne.github.io/post-images/1635758043362.webp" alt="" loading="lazy"></figure>
<h2 id="2-the-batman新蝙蝠侠蝙蝠侠传奇">2、The Batman(新蝙蝠侠/蝙蝠侠传奇)</h2>
<p>动画共五季</p>
<p>本作从蝙蝠侠刚刚出道打击罪犯的时候开始讲起，观众能看到年轻的布鲁斯·韦恩作为蝙蝠侠的成长历程，了解他是如何从一个普通人成长为一位超级英雄，期间经历了何种挫折与失败。本作的蝙蝠侠初出茅庐，各个方面都不成熟，不是刻板印象中，好似无所不知、时刻从容冷静的样子，但正因如此我们得以看到他成长的过程，也使得蝙蝠侠形象更加丰富饱满。这个版本的蝙蝠侠形象上更加年轻，整体画风也更加活泼。一开始，差点因为不太接受这个版本的画风，错过了一部好作品。喜欢蝙蝠侠的朋友，一定不要错过。</p>
<figure data-type="image" tabindex="2"><img src="https://Zoom-EobardThawne.github.io/post-images/1635759462159.webp" alt="" loading="lazy"></figure>
<h2 id="3-justice-league-action正义联盟在行动">3、 Justice League Action(正义联盟在行动)</h2>
<p>动画共一季（好希望出续作啊）</p>
<p>本作同样围绕着正义联盟成员的冒险故事展开，有别于JLU成人向的叙事风格，本作的剧情和人物塑造更加偏向儿童的喜好。画风更加鲜艳，角色形象也稍显可爱。虽是全年龄向的作品，但故事的精彩程度依旧不减。有赖于全年龄的基调，我们得以看见喜爱的英雄们更加活泼风趣的一面。</p>
<figure data-type="image" tabindex="3"><img src="https://Zoom-EobardThawne.github.io/post-images/1635759473755.webp" alt="" loading="lazy"></figure>
<h2 id="4-young-justice少年正义联盟">4、Young Justice(少年正义联盟)</h2>
<p>动画完播三季，21年将推出第四季</p>
<p>本作聚焦的是少年英雄，讲述了他们在老一辈英雄的带领和指导下，团结抗敌不断成长的故事。</p>
<figure data-type="image" tabindex="4"><img src="https://Zoom-EobardThawne.github.io/post-images/1635759680767.webp" alt="" loading="lazy"></figure>
<h1 id="dc动画电影">DC动画电影</h1>
<p>待续……</p>
<h1 id="dc真人电影">DC真人电影</h1>
<p>待续……</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Arduino+ESP8266的远程控制小车]]></title>
        <id>https://Zoom-EobardThawne.github.io/post/arduino-esp8266-car/</id>
        <link href="https://Zoom-EobardThawne.github.io/post/arduino-esp8266-car/">
        </link>
        <updated>2021-06-10T10:27:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="arduinoesp8266的远程控制小车">Arduino+ESP8266的远程控制小车</h1>
<h2 id="硬件选型">硬件选型</h2>
<h3 id="小车主控板arduino-uno">小车主控板：Arduino UNO</h3>
<p>​		Aruduino平台于2005年诞生，两位就职于米兰设计学院的教授，希望开发一款具有软件开发功能的开源的硬件实验平台，于是在他们的合作下，Arduino应运而生。Arduino的编程的语言脱胎于C，如果你有了C语言的学习经验的话，在了解了基本的语言特点和语法之后，便能够非常快速的在Arduino上进行独立的开发工作。关于Arduino的语言，主要有一下两部分，其一是setup()函数，该函数的作用只要在于对系统进行初始化，对相应的引脚进行定义，比如设置输入还是输出模式。第二部分是loop()函数，该函数是用来编写对应的功能的，同时loop()函数将启动硬件部分。不仅如此，Arduino拥有丰富的库文件，分为：官方提供和开发者自定义两种类型。</p>
<p>​		正如上文提到的，Arduino同时兼具软件开发的功能，拥有着自己的软件开发环境——Arduino IDE。它最为显著的特点就是可以跨多个平台运行，极大方便了使用。目前支持的平台包括：Linux、Windows和MacOS等。Arduino IDE是针对Arduino开发板的一个集成开源的编译软件，操作界面简单、语言风格与C语言相近、使用的库文件是开源的并且简单的代码可以直接通过串口进行下载。对于使用Arduino的开发者来说，这是一款首选的开发环境。<br>
<img src="https://Zoom-EobardThawne.github.io/post-images/1623321259204.png" alt="" loading="lazy"></p>
<p>​		ArduinoIDE是基于processing IDE开发的，是初学者十分的友好，能够快速的掌握，并具有很高的灵活性。Arduino的语言对于avr-gcc库二次封装，因而不需要太多的单片机和编程基础，便可以进行快速的开发。它的工作流程为，在开发者编写好代码，编译后，将语言转换成C++，再用avr-gcc将编译语言转换成二进制，这样一来，开发者编写的内容才能够背Arduino的硬件识别，程序才能够运行。这串代码通过USB接口连接到电脑，再上传到Arduino的存储器进行存储。</p>
<p>​		在开发者使用Arduino IDE的时候，要做好以下的准备工作：在PC端下载对应硬件的驱动，选择合适的端口。这些步骤完成之后，便可开始程序的编写。Arduino还有第三方的图形化编程软件，极大地降低了对开发者的编程能力的要求，只要能够符合逻辑的设计出功能，按照规定的方式设置对应的参数，便可以下载程序到硬件开发板进行使用。</p>
<p><a href="https://www.arduino.cc/en/software">Arduino软件下载</a><br>
<a href="https://www.arduino.cn/">Arduino中文社区</a></p>
<p>​		小车选用的是Arduino UNO的开发板，搭载芯片为ATmega328p。</p>
<figure data-type="image" tabindex="1"><img src="https://Zoom-EobardThawne.github.io/post-images/1623321351613.png" alt="" loading="lazy"></figure>
<p>​		同时为了方便对控制小车其他配件，选用了一块配套的功能转接板，如下所示：</p>
<figure data-type="image" tabindex="2"><img src="https://Zoom-EobardThawne.github.io/post-images/1623321379499.png" alt="" loading="lazy"></figure>
<p>​</p>
<h3 id="远程连接模块esp8266开发板">远程连接模块：ESP8266开发板</h3>
<p>小车采用ESP-12E开发板（NoteMCU）作为WIFI连接的模块，通过该块开发板连接物联网云平台，实现远程的控制实现。<br>
<img src="https://Zoom-EobardThawne.github.io/post-images/1623321413473.jpg" alt="" loading="lazy"></p>
<h3 id="其他配件">其他配件</h3>
<p>小车还需要的配件包括：四个直流电机，底盘，车轮，螺丝（若干），铜柱（若干），电池盒，可充电电池。</p>
<h2 id="云平台选择点灯科技blinker">云平台选择——点灯科技（Blinker）</h2>
<p><a href="https://www.diandeng.tech/home">官网首页</a></p>
<p><a href="https://www.diandeng.tech/doc">开发文档</a></p>
<h2 id="远程控制设计">远程控制设计</h2>
<h3 id="小车控制">小车控制</h3>
<p>远程控制功能主要分为两个主要部分，分别是对小车的动作控制和云平台连接。</p>
<p>小车的行动通过控制电机的转速来实现，单片机的I/O口输出不同的信号，改变驱动电路中PWM的比例值，进而对电机的转速进行调控。将对应的电机状态用函数进行封装，配合不同指令调用对应的函数来实现对小车的控制。</p>
<p>小车基本动作的函数如下表所示：</p>
<p>​																						小车基本动作函数</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>run()</td>
<td>小车向前进</td>
<td>左右电机前进</td>
</tr>
<tr>
<td>brake()</td>
<td>小车停止</td>
<td>左右电机停止</td>
</tr>
<tr>
<td>left()</td>
<td>小车左转</td>
<td>右电机前进左电机停止</td>
</tr>
<tr>
<td>right()</td>
<td>小车右转</td>
<td>右电机停止左电机前进</td>
</tr>
<tr>
<td>back()</td>
<td>小车后退</td>
<td>左右电机反转</td>
</tr>
</tbody>
</table>
<h3 id="云平台连接">云平台连接</h3>
<p>云平台远程连接采用ESP-12E开发板实现，首先通过ESP-12E板和物联网云平台（采用的是Blinker平台）进行远程连接，首先给开发板刷入Blinker的固件，当设备连接启动后，Arduino板通过串口向ESP-12E开发板发送AT指令，进行WIFI连接。连接成功后，就可以通过手机端向云平台发送指令，再由云平台发送给ESP-12E，Arduino通过串口读取指令，调用相应的动作函数。</p>
<p>​																							AT指令字段说明</p>
<table>
<thead>
<tr>
<th>AT指令</th>
<th>BLINKER_WIFI=0</th>
<th>3275431b24545</th>
<th>fa5</th>
<th>bruce6545555</th>
</tr>
</thead>
<tbody>
<tr>
<td>说明</td>
<td>模块工作于透传模式</td>
<td>绑定设备的密钥</td>
<td>WIFI名称</td>
<td>WIFI密码</td>
</tr>
</tbody>
</table>
<p>Bilnker云平台远程连接，主要分为新建组件、设置回调函数、绑定组件与回调函数三个步骤，主要的函数说明如下。</p>
<p>​																						远程连接主要函数说明</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>BlinkerButton ButtonRun(&quot;btn-run&quot;);</td>
<td>创建Button对象，键值为“btn-run”</td>
<td>对应Blinker app上的按键控件</td>
</tr>
<tr>
<td>void  buttonRun_callback(const String &amp; state)</td>
<td>获取按键的状态</td>
<td>根据按键的触发状态执行对应语句</td>
</tr>
<tr>
<td>ButtonRun.attach(buttonRun_callback)</td>
<td>绑定控件和对应的回调函数</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="源代码">源代码</h2>
<h3 id="小车控制部分">小车控制部分</h3>
<pre><code class="language-c">/***********************************************
  前进  按下发出 ONA  
  后退：按下发出 ONB  
  左转：按下发出 ONC  
  右转：按下发出 OND  
  停止：按下发出 ONE  
************************************************/
int Left_motor=8;     //左电机(IN3) 输出0  前进   输出1 后退
int Left_motor_pwm=9;     //左电机PWM调速

int Right_motor=11;    //右电机(IN1)  输出0  前进   输出1 后退
int Right_motor_pwm=10;    // 右电机PWM调速

char buffer[18];		//串口缓冲区的字符数组
void setup()			  //设定串口和引脚模式
{
     Serial.begin(9600);
     Serial.flush();		//清空串口缓存
     
     Serial.println(&quot;AT+BLINKER_WIFI=0,3275431b255e,f55,bruce6545555&quot;);

     pinMode(Left_motor,OUTPUT); // PIN 8 8脚无PWM功能
     pinMode(Left_motor_pwm,OUTPUT); // PIN 9 (PWM)
     pinMode(Right_motor_pwm,OUTPUT);// PIN 10 (PWM) 
     pinMode(Right_motor,OUTPUT);// PIN 11 
}
void run()     // 前进
{
  digitalWrite(Right_motor,LOW);  // 右电机前进
  digitalWrite(Right_motor_pwm,HIGH);  // 右电机前进     
  analogWrite(Right_motor_pwm,90);//PWM比例0~255调速，左右轮差异略增减
  
  
  digitalWrite(Left_motor,LOW);  // 左电机前进
  digitalWrite(Left_motor_pwm,HIGH);  //左电机PWM     
  analogWrite(Left_motor_pwm,90);//PWM比例0~255调速，左右轮差异略增减
  //delay(time * 100);   //执行时间，可以调整  
}

void brake()         //刹车，停车
{
  
  digitalWrite(Right_motor_pwm,LOW);  // 右电机PWM 调速输出0      
  analogWrite(Right_motor_pwm,0);//PWM比例0~255调速，左右轮差异略增减

  digitalWrite(Left_motor_pwm,LOW);  //左电机PWM 调速输出0          
  analogWrite(Left_motor_pwm,0);//PWM比例0~255调速，左右轮差异略增减
  //delay(time * 100);//执行时间，可以调整  
}

void left()         //左转(左轮不动，右轮前进)
{
   digitalWrite(Right_motor,LOW);  // 右电机前进
  digitalWrite(Right_motor_pwm,HIGH);  // 右电机前进     
  analogWrite(Right_motor_pwm,110);//PWM比例0~255调速，左右轮差异略增减
  
  
  digitalWrite(Left_motor,LOW);  // 左电机前进
  digitalWrite(Left_motor_pwm,LOW);  //左电机PWM     
  analogWrite(Left_motor_pwm,0);//PWM比例0~255调速，左右轮差异略增减
  //delay(time * 100);	//执行时间，可以调整  
}

void spin_left()         //左转(左轮后退，右轮前进)
{
  digitalWrite(Right_motor,LOW);  // 右电机前进
  digitalWrite(Right_motor_pwm,HIGH);  // 右电机前进     
  analogWrite(Right_motor_pwm,90);//PWM比例0~255调速，左右轮差异略增减
  
  digitalWrite(Left_motor,HIGH);  // 左电机后退
  digitalWrite(Left_motor_pwm,HIGH);  //左电机PWM     
  analogWrite(Left_motor_pwm,90);//PWM比例0~255调速，左右轮差异略增减
  //delay(time * 100);	//执行时间，可以调整  
}

void right()        //右转(右轮不动，左轮前进)
{
   digitalWrite(Right_motor,LOW);  // 右电机不转
  digitalWrite(Right_motor_pwm,LOW);  // 右电机PWM输出0     
  analogWrite(Right_motor_pwm,0);//PWM比例0~255调速，左右轮差异略增减
  
  
  digitalWrite(Left_motor,LOW);  // 左电机前进
  digitalWrite(Left_motor_pwm,HIGH);  //左电机PWM     
  analogWrite(Left_motor_pwm,110);//PWM比例0~255调速，左右轮差异略增减
  //delay(time * 100);	//执行时间，可以调整  
}

void spin_right()        //右转(右轮后退，左轮前进)
{
  digitalWrite(Right_motor,HIGH);  // 右电机后退
  digitalWrite(Right_motor_pwm,HIGH);  // 右电机PWM输出1     
  analogWrite(Right_motor_pwm,50);//PWM比例0~255调速，左右轮差异略增减
  
  
  digitalWrite(Left_motor,LOW);  // 左电机前进
  digitalWrite(Left_motor_pwm,HIGH);  //左电机PWM     
  analogWrite(Left_motor_pwm,50);//PWM比例0~255调速，左右轮差异略增减
  //delay(time * 100);	//执行时间，可以调整    
}

void back()          //后退
{
  digitalWrite(Right_motor,HIGH);  // 右电机后退
  digitalWrite(Right_motor_pwm,HIGH);  // 右电机前进     
  analogWrite(Right_motor_pwm,90);//PWM比例0~255调速，左右轮差异略增减
  
  
  digitalWrite(Left_motor,HIGH);  // 左电机后退
  digitalWrite(Left_motor_pwm,HIGH);  //左电机PWM     
  analogWrite(Left_motor_pwm,90);//PWM比例0~255调速，左右轮差异略增减
  //delay(time * 100);   //执行时间，可以调整    
}

void loop()
{
    if(Serial.available() &gt; 0)			//Serial.available()返回串口收到的字节数
    {
       int index = 0;
       delay(100);				//延时等待串口收完数据，否则刚收到1个字节时就会执行后续程序
       int numChar = Serial.available();	
       if(numChar &gt; 15)				//确认数据不会溢出，应当小于缓冲大小
       {
         numChar = 15;
        }
       while(numChar--)
      {
          buffer[index++] = Serial.read();	//将串口数据一字一字的存入缓冲
      }
      Serial.println(buffer);
      splitString(buffer);				//字符串分割
    }
    
}

void splitString(char *data)
{
       Serial.print(&quot;Data entered:&quot;);
       Serial.println(data);
       char *parameter;
       parameter = strtok(data, &quot; ,&quot;);		//string token，将data按照空格或者,进行分割并截取
       Serial.println(parameter);
    while(parameter != NULL)
  {
    setMove(parameter);
    parameter = strtok(NULL, &quot; ,&quot;);		//string token，再次分割并截取，直至截取后的字符为空
    Serial.println(parameter);			
   }
   for(int x = 0; x &lt; 16; x++)			//清空缓冲
  {
   buffer[x] = '\0';
  }
     Serial.flush();
}

void setMove(char *data)
{
   if((data[0] == 'O') &amp;&amp; (data[1] == 'N')&amp;&amp; (data[2] == 'A'))
   {
    Serial.println(&quot;go forward!&quot;); 
      run();
  }
  if((data[0] == 'O') &amp;&amp; (data[1] == 'N')&amp;&amp; (data[2] == 'B'))
   {
    Serial.println(&quot;go back!&quot;); 
      back(); 
 }
    if((data[0] == 'O') &amp;&amp; (data[1] == 'N')&amp;&amp; (data[2] == 'C'))
   {
      Serial.println(&quot;go left!&quot;); 
      left();
  }
    if((data[0] == 'O') &amp;&amp; (data[1] == 'N')&amp;&amp; (data[2] == 'D'))
   {
     Serial.println(&quot;go right!&quot;); 
      right(); 
  }
    if((data[0] == 'O') &amp;&amp; (data[1] == 'N')&amp;&amp; (data[2] == 'E'))
   {
      Serial.println(&quot;Stop!&quot;); 
      brake(); 
  }
    if((data[0] == 'O') &amp;&amp; (data[1] == 'N')&amp;&amp; (data[2] == 'F'))
   {
    Serial.println(&quot;Stop!&quot;); 
     brake();  
   }
   
}
</code></pre>
<h3 id="远程连接部分烧制在esp-12e开发板">远程连接部分（烧制在ESP-12E开发板）</h3>
<pre><code class="language-c">#define BLINKER_AT_MQTT
#include &lt;Blinker.h&gt;

// 新建组件对象
BlinkerButton ButtonRun(&quot;btn-run&quot;);
BlinkerButton ButtonBack(&quot;btn-back&quot;);
BlinkerButton ButtonLeft(&quot;btn-left&quot;);
BlinkerButton ButtonRight(&quot;btn-right&quot;);
BlinkerButton ButtonStop(&quot;btn-stop&quot;);
BlinkerButton ButtonOn(&quot;btn-on&quot;);
BlinkerButton ButtonOff(&quot;btn-off&quot;);
int counter = 0;

// 按键回调函数
void buttonRun_callback(const String &amp; state)
{
  if (state == BLINKER_CMD_BUTTON_PRESSED){
     Serial.write(&quot;ONA&quot;);
  }
  else if (state == BLINKER_CMD_BUTTON_RELEASED){
     Serial.write(&quot;ONE&quot;);
  }
  else{
      Serial.write(&quot;ONA&quot;);
      delay(1000);
      Serial.write(&quot;ONE&quot;); 
  }
}
void buttonBack_callback(const String &amp; state)
{
   if (state == BLINKER_CMD_BUTTON_PRESSED){
     Serial.write(&quot;ONB&quot;);
  }
  else if (state == BLINKER_CMD_BUTTON_RELEASED){
     Serial.write(&quot;ONE&quot;);
  }
  else{
      Serial.write(&quot;ONB&quot;);
      delay(1000);
      Serial.write(&quot;ONE&quot;); 
  }
}
void buttonLeft_callback(const String &amp; state)
{
   if (state == BLINKER_CMD_BUTTON_PRESSED){
     Serial.write(&quot;ONC&quot;);
  }
  else if (state == BLINKER_CMD_BUTTON_RELEASED){
     Serial.write(&quot;ONE&quot;);
  }
  else{
      Serial.write(&quot;ONC&quot;);
      delay(1000);
      Serial.write(&quot;ONE&quot;); 
  }
}
void buttonRight_callback(const String &amp; state)
{
    if (state == BLINKER_CMD_BUTTON_PRESSED){
     Serial.write(&quot;OND&quot;);
  }
  else if (state == BLINKER_CMD_BUTTON_RELEASED){
     Serial.write(&quot;ONE&quot;);
  }
  else{
      Serial.write(&quot;OND&quot;);
      delay(1000);
      Serial.write(&quot;ONE&quot;); 
  }
}
void buttonStop_callback(const String &amp; state)
{
   Serial.write(&quot;ONE&quot;);
}
void buttonOn_callback(const String &amp; state)
{
   digitalWrite(2,LOW);
   Serial.write(&quot;ONF&quot;);
}
void buttonOff_callback(const String &amp; state)
{
   digitalWrite(2,HIGH);
}
void setup()
{
    Blinker.begin();

    pinMode(2,OUTPUT);
    
    ButtonRun.attach(buttonRun_callback);
    ButtonBack.attach(buttonBack_callback);
    ButtonLeft.attach(buttonLeft_callback);
    ButtonRight.attach(buttonRight_callback);
    ButtonStop.attach(buttonStop_callback);

    ButtonOn.attach(buttonOn_callback);
    ButtonOff.attach(buttonOff_callback);
    
}

void loop() {
 // char ch=Serial.read(); // 读取输入的信息
 //Serial.print(ch);  //输出信息
 //delay(1000); 
    Blinker.run();
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个简单的自定义栈]]></title>
        <id>https://Zoom-EobardThawne.github.io/post/zi-ding-yi-zhan/</id>
        <link href="https://Zoom-EobardThawne.github.io/post/zi-ding-yi-zhan/">
        </link>
        <updated>2021-05-13T17:12:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="自定义一个栈in-c">自定义一个栈（In C++）</h2>
<h3 id="在头文件-my_stackh-中自定义栈">在头文件 my_stack.h 中自定义栈。</h3>
<ol>
<li>自定义栈的类的数据成员和公有函数:</li>
</ol>
<pre><code class="language-cpp">#pragma once
#include &lt;iostream&gt;
using namespace std;

template &lt;typename Type&gt;
class Stack
{
private:
    Type *stk; //起始地址
    int MAXN;  //最大容量
    int top;   //指向栈顶元素（下标）
public:
    Stack(int size); //初始化
    ~Stack();
    bool empty() const;   //判断空
    bool full() const;    //判断满
    bool push(Type x);    //入栈
    bool pop();           //出栈
    Type get_top() const; //取栈顶元素
    int size() const;     //栈大小
    int Max() const;      //最大容量
};
</code></pre>
<ol start="2">
<li>函数的定义：</li>
</ol>
<pre><code class="language-cpp">template &lt;typename Type&gt;
Stack&lt;Type&gt;::Stack(int size)
{
    MAXN = size;
    stk = new Type[MAXN];
    top = -1;
} //栈初始化

template &lt;typename Type&gt;
Stack&lt;Type&gt;::~Stack()
{
    delete stk;
} //析构函数定义

template &lt;typename Type&gt;
bool Stack&lt;Type&gt;::empty() const
{
    if (top == -1)
    {
        return true;
        cout &lt;&lt; &quot;underflow&quot; &lt;&lt; endl;
    }
    return false;
}

template &lt;typename Type&gt;
bool Stack&lt;Type&gt;::full() const
{
    if (top == MAXN - 1)
    {
        return true;
        cout &lt;&lt; &quot;overflow&quot; &lt;&lt; endl;
    }
    return false;
}

template &lt;typename Type&gt;
bool Stack&lt;Type&gt;::push(Type x)
{
    if (full())
    {
        return false;
        cout &lt;&lt; &quot;overflow&quot; &lt;&lt; endl;
    }
    stk[++top] = x;
    return true;
}

template &lt;typename Type&gt;
bool Stack&lt;Type&gt;::pop()
{
    if (empty())
    {
        return false;
        cout &lt;&lt; &quot;underflow&quot; &lt;&lt; endl;
    }
    top--;
    return true;
}

template &lt;typename Type&gt;
Type Stack&lt;Type&gt;::get_top() const
{
    if (empty())
    {
        return false;
        cout &lt;&lt; &quot;underflow&quot; &lt;&lt; endl;
    }
    return stk[top];
}

template &lt;typename Type&gt;
int Stack&lt;Type&gt;::size() const
{
    return top + 1;
}

template &lt;typename Type&gt;
int Stack&lt;Type&gt;::Max() const
{
    return this -&gt;MAXN;
}
</code></pre>
<h3 id="在源文件my_stackcpp中创建一个栈对象实现栈的基本操作">在源文件my_stack.cpp中创建一个栈对象，实现栈的基本操作。</h3>
<ol>
<li>创建对象，实现栈的基本操作。</li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &quot;my_stack.h&quot;
using namespace std;

int main()
{
    int n, x, ele, i; //最大长度；元素个数；元素；输入元素循环次数
enter:
    cout &lt;&lt; &quot;enter max length of stack :&quot; &lt;&lt; endl;
    cin &gt;&gt; n;
    cout &lt;&lt; &quot;--------------------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;enter numbers of elements:&quot; &lt;&lt; endl;
    cin &gt;&gt; x;
    cout &lt;&lt; &quot;--------------------------------&quot; &lt;&lt; endl;
    if (x &gt;= n)
    {
        cout &lt;&lt; &quot;failed! numbers of elements must less than max length!&quot; &lt;&lt; endl
             &lt;&lt; &quot;please enter again!&quot; &lt;&lt; endl;
        goto enter;
    }
    /*创建栈对象*/
    Stack&lt;int&gt; s(n);
    cout &lt;&lt; &quot;The max length is : &quot; &lt;&lt; s.Max() &lt;&lt; endl;
    cout &lt;&lt; &quot;--------------------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;enter your elements:&quot; &lt;&lt; endl;
    /* 循环元素入栈 */
    for (i = 0; i &lt; x; i++)
    {
        cin &gt;&gt; ele;
        s.push(ele);
    }
    /* 元素出栈 */
    cout &lt;&lt; &quot;--------------------------------&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;stack size:&quot; &lt;&lt; s.size() &lt;&lt; endl;
    cout &lt;&lt; &quot;output elements:&quot; &lt;&lt; endl;

    while (s.empty() != true)
    {
        cout &lt;&lt; s.get_top() &lt;&lt; endl;    //取栈顶元素
        s.pop();
    }

    cout &lt;&lt; &quot;stack size:&quot; &lt;&lt; s.size() &lt;&lt; endl;
    cout &lt;&lt; &quot;--------------------------------&quot; &lt;&lt; endl;

    return 0;
}
</code></pre>
<ol start="2">
<li>用模板类的时候注意编写的格式。</li>
</ol>
<pre><code class="language-cpp">模板类外函数定义：
template &lt;typename 类型参数&gt;
函数类型 类名&lt;类型参数&gt;：：成员函数名（形参表）
{
	……
}
</code></pre>
<ol start="3">
<li>运行结果。<br>
<img src="https://Zoom-EobardThawne.github.io/post-images/1622999602288.png" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Welcome to 闲卧庭前远看帆的小窝]]></title>
        <id>https://Zoom-EobardThawne.github.io/post/welcome/</id>
        <link href="https://Zoom-EobardThawne.github.io/post/welcome/">
        </link>
        <updated>2021-05-09T18:19:34.000Z</updated>
        <content type="html"><![CDATA[<p>🚀关于本站：生活记录，学习心得，影视分享。</p>
<p>🍭Favorite：<br>
🎬：《黑客帝国》 《让子弹飞》 《蝙蝠侠》《冰雪奇缘》<br>
《疯狂动物城》 《西西里的美丽传说》<br>
🎧：《Hello》 《Someone like you》 《When we were young》《印第安老斑鸠》<br>
《假如爱有天意》 《当你老了》 《车站》 《父亲写的散文诗》<br>
《这里的黎明静悄悄》<br>
📖：《追风筝的人》 《不能承受的生命之轻》 《克苏鲁神话》 《毛泽东文选》<br>
《百年孤独》</p>
<p>❤️Follow me❤️：<br>
B站： <a href="https://space.bilibili.com/147998660">闲卧庭前远看帆</a><br>
Github： <a href="https://github.com/Zoom-EobardThawne">Zoom-EobardThawne</a><br>
Lofter：<a href="https://bruce1808759299.lofter.com/">闲卧庭前远看帆</a></p>
]]></content>
    </entry>
</feed>